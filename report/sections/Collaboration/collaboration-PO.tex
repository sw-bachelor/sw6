\section{Collaboration between PO and developer groups}
As the PO group we were responsible for making and maintaining user stories for the developer groups.
Whenever a group needed a new task they would have to come to us and ask for permission before assigning themselves to a user story.
This gave us a good overview of what groups were working on and where merge conflicts might arise.
Merge conflicts were resource intensive as they could alter the way a group had gone about solving a user story, requiring major code rewriting, or delay them from completing their user story.
Therefore, it was important for us to have as much overview as possible of the developer groups, so that we could warn them if merge conflicts could become a problem and advise them to talk to the corresponding group working in the same set of files.
\\
\\
During the project we often noticed that some user stories were not completed in time despite us never having heard of any trouble from the groups responsible for the user stories.
We therefore started visiting the other groups to ask them how far they had come with their user stories.
This gave us a much better understanding of the problems that the developer groups were experiencing. 
Based on our knowledge of what all the groups had been working on prior, we were able to recruit people from different groups to come work as consultants to help groups that were stuck.
In extreme situations we would decide to reallocate a user story to a different group if the original group did not have enough time to finish it before the sprint ended.
This greatly increased the productivity as some user stories could be stuck for weeks and then be fixed in a matter of days.
\\
\\
To further help the developer groups we made prototypes for each user story to better convey what the customers wished to have implemented and how it should look.
Developer groups would often visit us for clarification of why the prototypes looked as they did, whether or not they were allowed to change certain aspects, and how the interaction between prototypes worked, such as if it should be a simple button press or a hold, should there be a pop up window or a whole new screen etc.
The prototypes they were handed were approved by customers, so direct changes were in most cases denied, but this also helped the developer groups get a bit of insight into the choices that we had taken.
\\
\\
When a sprint was at its end we would choose the features that were finished that we wanted to include in a new release.
Together with the process group we would create a table where each group would get responsibility for checking a number of features, functionality, and whether or not new bugs were introduced since merging all the different branches.
To better organize this the we created a release branch together with the process group.
From this branch all the release fixes were branched out and merged into when done.
When working on the release branch all groups were gathered in one room where everyone would be working on getting the application ready for release.
This meant that if there was any question about how a feature worked the group who created it would be present and ready to help if needed.
