\chapter{Code generation}
The code generation is the final phase of the compiler, it is responsible for traversal of the AST and generating the appropriate APL code. 
Doing this chapter we will look at the different overrides of the visit methods responsible for generating the APL code.
\\\\
The code generation class inherits from the visitor class to enable the traversal of the AST, just like the type checker. Every node of the AST must be visited in order to generate the corresponding code in APL. The first listing to look at is the one for a whole program.

\begin{lstlisting}[caption={Code generator for a program}, label={code:CodeGeneratorVisit}]
@Override
public void visit(ProgramNode node) {
  printHeader();
  printCmpIncludes();

  for (IncludeNode incl : node.includeNodes) {
    visit(incl);
  }
  for (SetupCntNode dcl : node.setupNode.setupCntNodes) {
    if (dcl.dclNode instanceof VarDclNode) {
      visit((VarDclNode) dcl.dclNode, CodeGen.GLOBAL);
    }
    if (dcl.dclNode instanceof ListNode) {
      visit((ListNode) dcl.dclNode, CodeGen.GLOBAL);
    }
    if (dcl.dclNode instanceof GroupNode) {
      visit((GroupNode) dcl.dclNode, CodeGen.GLOBAL);
    }
    if (dcl.dclNode instanceof CmpDclNode) {
      visit((CmpDclNode) dcl.dclNode, CodeGen.GLOBAL);
    }
  }

  visit(node.setupNode);
  visit(node.repeatNode);

  for (FuncNode func : node.funcNodes) {
    visit(func);
  }
  writer.close();
}
\end{lstlisting}
Listing~\ref{code:CodeGeneratorVisit} is responsible for checking the strcuture of the program and calling the approriate visit methods to convert from PHAL to APL based on note types.
On Listing~ line 3, the header of the APL file is added to state that the code is generated by the PHAL compiler stating the date of compilation. 
Line 4 simply writes the includes to the output file. The for loop starting on line 9 if used for declaring variables globally. After global variables have been generated, this method calls the visit methods for setup part of the program, then the repeat part and finally the function declarations that end the general structure of a PHAL program. Once every part of the program is visited, link 29 closes the writer, meaning the program has finished compilation.

\begin{lstlisting}[caption={Generating code for a variable declaration }, label={code:CodeGenVarDcl}]
public void visit(VarDclNode node, Enum<CodeGen> location) {
  if (location == CodeGen.GLOBAL) {
    visit(node.typeNode);
    writer.print(" ");
    visit(node.idNode);
  }

  if (location == CodeGen.SETUP) {
    if (node.exprNode != null) {
      visit(node.idNode);
      writer.print(" = ");
      visit(node.exprNode);
    }
  }

  if (location == CodeGen.FUNCTION) {
    visit(node.typeNode);
    writer.print(" ");
    visit(node.idNode);
    if (node.exprNode != null) {
      writer.print(" = ");
      visit(node.exprNode);
    }
  }
  writer.print(";\n");
}
\end{lstlisting}
To generate code for declarations, the location where they appear must be taken into account. As shown in the for loop on Listing~\ref{code:CodeGeneratorVisit} line 9, the location is given as input through a CodeGen enum. This location is then used in the code shown in Listing~\ref{code:CodeGenVarDcl} to determine how the code is generated. If the location is global, it visits the type node to generate the type, prints a space and then generates the identifier. The variables in setup are defined through the global scope, but initialised in setup, which is why variables with that location do not visit the \textit{typeNode}. If the variable is declared in a function, it must check the type and initialise. 

\begin{lstlisting}[caption={Generating code for the repeat section of PHAL}, label={code:ReapeatGen}]
@Override
public void visit(RepeatNode node) {
  writer.print("void loop(){ \n");
  super.visit(node);
  writer.print("} \n\n");
}
\end{lstlisting}
The APL equivalent to our repeat is loop. Therefore, when generating code for the RepeatNode we generate the loop function. Inside the loop functions block we use the \textit{super.visit} to call the visitor function of the visitor class. This is done to prevent code duplication because the visit function in the Visitor class that takes the RepeatNode as parameter already visits all its contents.
\begin{lstlisting}[caption={Generating code for an assignment statement}, label={code:AssignStatement}, escapeinside={(*}{*)}]
@Override
public void visit(AssignmentNode node) {
  if (node.idNode.type == Type.GROUP) {
    if (node.assignmentOperator == AssignmentOperator.EQUALS) {
      visit(node.idNode);
      LiteralExprNode le = (LiteralExprNode) node.exprNode;

      switch (le.literalExprNode) {
        case "true":
        case "on":
          writer.print(".on();\n");
          break;
        (*\vdots*)
      }
    }
  } 
  (*\vdots*)
  else {
    visit(node.idNode);
    if (node.assignmentOperator == AssignmentOperator.EQUALS) {
      writer.print(" = ");
    } else {
      writer.print(node.assignmentOperator.toString());
    }
    visit(node.exprNode);
    writer.print(";\n");
  }
}
\end{lstlisting}
The assignment statements shown in Listing~\ref{code:AssignStatement} differ based on the type that is assigned to. 
Groups and list require different implementation than the basic types: text, number and bool that are assigned to through in the same way. 
This means the first thing to check is the type of the node given as a parameter. 
For groups, the next thing to check is whether the operator used for assignment is equal to the one defined for assignments in the \textit{AssignmentOperator} enumeration type, as seen on line 4. 
\\\\
If the syntax is correct, it visits the node, converts it to a literal expression node, and switches what to print based on the boolean value or its alias. 
\\\\
If the node is of any other type than list or group, the generator either prints an equal sign or the value of the \textit{assignmentOperator} on the node as a string. 
Finally, on line 25 the expression is visited and a semicolon is printed to conform to the APL rule for ending statements.

\begin{lstlisting}[caption={Generating code for an if-statement}, label={code:IfStatement}]
@Override
public void visit(IfStmtNode node) {
  writer.write("if(");
  visit(node.ifExprNode);
  writer.write("){\n");
  visit(node.ifBlock);
  writer.write("\n}\n");

  for (ElseIfStmtNode elif : node.elseIfStmts) {
    visit(elif);
  }
  if (node.elseBlock != null) {
    visit(node.elseBlock);
  }
}
\end{lstlisting}
Listing~\ref{code:IfStatement} details the generation of code related to if-statements. The visit function takes the node of type \textit{IfStmtNode}, and initially outputs the keyword \textit{if} and a starting parenthesis. 
It then generates the expression used as the condition, finishes the first line of the if-statement and sets up the block. 
\\\\
The if-block contains a list of the statements used within the block. 
After this each identifier of type \textit{ElseIfStmtNode} within the node is visited. 
The \textit{elseIfStmts} contains an expression as a condition and a block containing statements. 
Finally, if the else block is is present, it is visited and the list of statements used within is generated.
\section*{Example of generated code}
In Listings~\ref{code:PHALSourceCode} and \ref{code:GeneratedArduinoCode} is an example that shows the difference between the source code and generated code.
\begin{lstlisting}[caption={Source code written in PHAL}, label={code:PHALSourceCode}]
setup{
  lightbulb l1 := pin 1
  lightbulb l2 := pin 2
  
  group lights{
    l1
    l2
  }
}

repeat{
  lights := on
  wait 5 seconds
  lights := off
}
\end{lstlisting}


\begin{lstlisting}[caption={Generated Arduino code}, label={code:GeneratedArduinoCode}]
/* Phal AutoGenerated .ino file 
*  Created 25-05-2018
*/

#include "Lightbulb.h" 
Lightbulb *l1;
Lightbulb *l2;
PhalGroup *lights = new PhalGroup();

void setup(){ 
  l1 = new Lightbulb(1);
  l2 = new Lightbulb(2);
  lights->add(l1);
  lights->add(l2);
} 

void loop(){ 
  lights->on();
  delay((5)*1000);
  lights->off();
} 
\end{lstlisting}
\section*{Summary}
With the code generation implementation done, it is now possible to translate PHAL source code into APL. Having this done, it is possible to transfer a PHAL based program to the Arduino platform using the Arduino CLI and the intermediate code representation.\\