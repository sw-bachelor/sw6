\chapter{Code generation}\label{ch:CodeGenerationTheory}
The final phase of the compiler is the code generation phase.
When entering the code generation phase, the source program should have been transformed into an intermediate representation, usually in the form of an \textit{Abstract Syntax Tree} after passing through the previous phases of the compiler.
During this chapter, the goals and challenges associated with designing a code generator will be discussed. 
Furthermore, some of the techniques used in code optimisation will be introduced and discussed.

\section{The role of the code generator}
The role of the code generator is to produce the final output of the compiler based on the input program. This can take many different forms such as different types of machine languages or intermediate code \cite{Dragon}. 
\\\\
By compiling to machine language, the main advantage is that it can often be loaded directly into a fixed location in the memory of the device and can be executed immediately. This also has the advantage that small programs can be compiled and executed quickly \cite{Dragon}.
\\\\
However, compiling to another intermediate code is a widely used technique that makes use of previously written compilers to generate the executable code, decreasing the amount of work needed to be done when crafting a new compiler \cite{Dragon}.
\\
Several challenges can occur however when designing the code generator. 
These challenges must be kept in mind from the beginning, in order to create a successful code generator, and some of these challenges will be further described in this section.

%\subsection{Memory Management}
%Memory management problems can occur, depending on the output of the compiler. 
%The issue of memory management can be imminent when dealing with machine language programs since they %usually do not provide an easy way to deal with memory allocation and garbage collection.
%When the output of a compiler is in machine language, it is up to the designers of the code generator to keep track of memory allocation and garbage collection, otherwise the physical memory of the hardware platform might end up being filled.
%However, if the output of a compiler is in an intermediate code form, the memory management is usually handled by the compiler for the intermediate language.


%\subsection{Peephole optimisation}
%When trying to optimise code it is important to remember that optimised code is nothing more than that and should not be confused with optimal code.
%The purpose of optimised code is to reduce the overall running time \cite{Dragon}.
%\\\\
%A statement-by-statement approach applied in code generation will often result in target code containing redundant instructions \cite{Dragon}.
%A simple but effective technique for locally improving the target code is called \textit{peephole optimisation}. 
%The technique tries to improve the performance of the target program by examining a short sequence of instructions, called the peephole, and replacing the instructions with shorter or faster sequences whenever possible. 
%\\\\
%In the following subsections we will describe some of the easiest instructions to optimise \cite{Dragon}.

%\subsection{Unreachable code}
%One of the code sequences that is often easy to optimise is unreachable code. 
%To optimise unreachable code it simply needs to be eliminated. 
%The code generator has to determine whether parts of the code are unreachable, and therefore never executed. In this case it would make sense for the code generator to simply skip the excessive code bits.\\
%An example of unreachable code can be seen on listing~\ref{Code:UnreachableCode}
%\begin{lstlisting}[caption={Example of unreachable code}, label={Code:UnreachableCode}]
%lightbulb lamp := pin 1
%if (true is false) then
%{
%    lamp := on
%}
%\end{lstlisting}
%In Listing~\ref{Code:UnreachableCode}, the code generator should detect whether the condition of the %\textit{if}-statement is never going to be fulfilled, and conclude whether the entire In %\textit{if}-statement is unreachable and therefore not included in the target program.


%\subsection{Algebraic simplification}
%Another way to optimise the target program is to simplify algebraic expressions.
%Optimising algebraic expressions means that redundant algebraic expressions can be removed without altering the result. An example of this can be seen on Listing~\ref{Code:BadMath}.
%\begin{lstlisting}[caption={Example of an algebraic expression that can be optimised}, label={Code:BadMath}]
%x := x + 0
%or
%x := x * 1
%\end{lstlisting}
%In the listing both are legal expressions, but the results of the expressions have less complicated equivalents which can be be applied instead. In both examples, the right-most side of the expression can be ignored, without altering the result.

\section{Summary}
In this part, the usage of contextual grammar and the rules of the language have been defined, allowing the implementation of the compiler to begin.\\
In addition to this, the processes of a compiler have been theoretically described, and will be elaborated upon in the following part, where the theory will be supplemented with some code examples to further elaborate on how a compiler is crafted.

